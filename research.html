<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="jemdoc.css" type="text/css" />
<title>Shuai Zhang Postdoc@RPI </title>
</head>
<body>
<table summary="Table for page layout." id="tlayout">
<tr valign="top">
<td id="layout-menu">
<div class="menu-category">Shuai@RPI</div>
<div class="menu-item"><a href="index.html">Home</a></div>
<div class="menu-item"><a href="cv\CV.pdf">CV</a></div>
<div class="menu-category">Research</div>
<div class="menu-item"><a href="research.html" class="current">Projects</a></div>
<div class="menu-item"><a href="publications.html">Publications</a></div>
<div class="menu-category">Others</div>
<div class="menu-item"><a href="talk.html">Talks</a></div>
</td>
</td>
<td id="layout-content">
<div id="toptitle">
<h1>Projects</h1>
</div>
  <p>My current research and project mainly lies in the following two aspects: <em>Theoretical foundation of deep/machine learning</em> and <em>Efficient learning algorithm</em>. </p>
<h2>Theoretical foundation of deep/machine learning</h2>
<ul>
<li><p>Deep learning explanation, convergence, and generalization analysis</p>
</li>
<li><p>Graph neural network learning theory</p>
</li>
<li><p>Fairness in deep/machine learning</p>
</li>
  <li><p>Deep reinforcement learning theory </p>
</li>
<li><p>Matrix completion </p>
</li>
</ul>
<h2>Efficient learning algorithm</h2>
<ul>
<li><p>Neural network compression </p>
</li>
<li><p>Data compression</p>
  </li>
<li><p>Efficient neural network architectures</p>
</li>
<li><p>Few-shot learning</p>
</li>
<li><p>Prompt engineering</p>
</li>  
</ul>
  <h1>Research highlights</h1>
</div>
  <h2> Neural network pruning <a href="research/SNN.pdf">[slides]</a> </h2>
<b>Discription</b>:  Neural network pruning is a technique used to reduce the size of a neural network by removing unnecessary connections and neurons while maintaining or improving its performance. This technique can help to make the network more sparse, leading to several advantages such as decreased computational cost, memory usage, energy consumption, and carbon footprint. Furthermore, recent numerical findings have indicated that a well-pruned neural network can exhibit improved test accuracy and faster convergence rates. This type of pruned network is commonly referred to as "winning tickets" within the context of the lottery ticket hypothesis (LTH), and numerical evidence suggests that magnitude-based pruning is effective in finding such "winning tickets". However, LTH and its relevant paper cannot explain the benefits of training the "winning tickets" and why using magnitude-based pruning approach can find the "winning tickets". 
  
   <p><center> <img src="research/NP1.png" width="600" height=auto> </center></p>
  
  
  <p><li> <b>First, we provide the theoretical guarantees for using magnitude-based pruning in finding the "winning ticket". </b> Specifically, we proves that the neuron weights that learns class-irrevelant features, e.g., background/noise features, tend to have a small magnitude. Therefore, removing the neuron weights with small magnitude will not change the expressive power of the neural network in learning good features (class-relevant features).  
</li></p>
  
  <p><center> <img src="research/NT5.PNG" width="700" height=auto> </center></p>
  
  <p><li> <b>Second, we provide the theoretical explanations for a good pruning network in achieving improved test accuracy and accelerated convergence rate.</b> Specifically, our analysis demonstrates that training the "winning ticket" corresponds to a wider and steeper convergence zone, which significantly diminishes the generalization gap, resulting in improved test accuracy. Consequently, training on a "winning ticket" necessitates fewer samples to achieve a sound initialization and ensure convergence, resulting in quicker convergence rates and reduced generalization errors for the algorithm.
</li></p>
  
  <p><center> <img src="research/NT2.PNG" width="530" height=auto> <img src="research/NT3.PNG" width="230" height=auto> </center></p>
  
   <p><li> Numerical verification for the improved performance by using magnitude-based pruning.</li> </p>
  
    <p><center> <img src="research/NT4.PNG" width="700" height=auto> </center></p>
  
  <p><li><b>Selected Publications</b>:</p>
</li>
</ul>
<ol>
 <li><p><b>Shuai Zhang</b>, Meng Wang, Pin-Yu Chen, Sijia Liu, Songtao Lu, Miao Liu. “<em>Joint Edge-Model Sparse Learning is Provably Efficient for Graph Neural Networks.</em>” In International Conference on Learning Representations (<b>ICLR</b>), 2023. [<a href="Pub/ICLR23.pdf">pdf</a>]</p>
</li>
  <li><p><b>Shuai Zhang</b>, Meng Wang, Sijia Liu, Pin-Yu Chen, and Jinjun Xiong. “<em>Why Lottery Ticket Wins? A Theoretical Perspective of Sample Complexity on Sparse Neural Networks.</em>” In Proc. of the Thirty-fifth Conference on Neural Information Processing Systems (<b>NeurIPS</b>), 2021. [<a href="Pub/NeurIPS21.pdf">pdf</a>]</p>
</li>
</ol>
  
 <h2>Self-training via unlabeled data (semi-supervised learning) <a href="research/ST.pdf">[slides]</a></h2>
<p><b>Discription</b>: Self-training is a type of semi-supervised learning approaches that combines labeled and unlabeled data to improve the accuracy of a model. It is useful in situations where obtaining labeled data is expensive or time-consuming, but there is an abundance of unlabeled data available. In many real-world scenarios, labeled data can be scarce or difficult to obtain, e.g., medical images, and labeling large datasets can be expensive or time-consuming, e.g., labeling ImageNet took almost 4 years with 49,000 workers from 167 countries. Most importantly, by incorporating unlabeled data, self-training can improve the accuracy of a model beyond what is possible with purely labeled data. Despite the use of self-training and deep learning in various studies, there is currently a lack of theoretical understanding regarding their integration and performance. In addition, certain numerical experiments have indicated that the non-linear characteristics of neural networks could result in a decline in performance when utilizing self-training. To address the disparity between numerical results and theoretical comprehension of self-training, we present a convergence analysis of the self-training algorithm, along with theoretical guidelines for selecting hyperparameters to ensure improved generalization using unlabeled data.   Our specific contributions include </p>
 
<center> <img src="research/ST4.PNG" width="750" height=auto> </center>
  
<p><li> <b>First, we provide quantitative justification of generalization improvement by using unlabeled data.</b>. Specifically, we prove that the improved generalization is a linear function of 1/\sqrt{M}, where M is the number of unlabeled data. 
</li></p>
  
<center>  <img src="research/ST2.PNG" width="600" height=auto></center>
  
<p><li> <b>Second, we provide analytical justification for the hyperparameter selection in guarantee improved performance when using unlabeled data.</b>. Our analysis focuses on the impact of the weighted loss parameter, denoted as \lambda. Lowering the value of \lambda results in a decrease in performance, while increasing it too much can cause the algorithm to diverge. The optimal value of \lambda is approximately \sqrt{N}/(\sqrt{M}+\sqrt{N}), where M and N represent the number of unlabeled and labeled data, respectively. Alternatively, one can progressively raise \lambda until the point where the algorithm diverges.
</li></p>
    <p> <center> <img src="research/st1.PNG" width="500" height=auto></center> </p>
  
<p><li> <b>Third, we provide the convergence and sample complexity analysis for learning a proper model.</b> We quantify the impact of labeled and unlabeled data on the generalization of the learned model, and we show that the iterations converges to the desired model with a characterizable bound with sufficient large number of unlabeled data. 
</li></p>  

  
  <p> <center> <img src="research/ST3.PNG" width="750" height=auto></center> </p>
  
<p><li><b>Selected Publications</b>:</p>
</li>
</ul>
<ol>
 <li><p><b>Shuai Zhang</b>, Meng Wang, Sijia Liu, Pin-Yu Chen, and Jinjun Xiong. “<em>How unlabeled data improve generalization in self-training? A one-hidden-layer theoretical analysis</em>.” In Proc. of The Tenth International Conference on Learning Representations (<b>ICLR</b>), 2022. [<a href="Pub/ICLR22.pdf">pdf</a>]</p>
</li>
</ol>
  
  <h2> Graph Neural Networks  <a href="research/GNN.pdf">[slides]</a></h2>
  <p><b>Discription</b>: Graph neural networks (GNNs) are a class of deep learning models that are designed for data learning with graph structured data. Examples of data that can be represented as graphs include social networks, biological networks, recommendation systems, communication networks, Internet of Things (IoTs) networks, and transporation networks. 
  <p><center> <img src="research/GNN1.PNG" width="600" height=auto></center></p>
Compared with traditional neural networks, GNNs propagate information across the graph through a series of neural network layers. At each layer, each node aggregates information from its neighboring nodes and updates its own representation accordingly. The aggregation and update rules are learned by the model during training, allowing it to capture complex patterns and dependencies in the graph. GNNs have been shown to be effective in a wide range of applications, including node classification, link prediction, and graph classification. 

However, Training and inference of graph neural networks (GNNs) suffer from high computational costs, which prevents GNNs from being scaled up to large-scale real-world graph applications.  
On the one hand, the computational complexity for processing the entire graph grows as an exponential function as the size of the dataset. As a comparison, the computational complexity of a GNN is much higher than some popular convolutional neural networks (CNNs) with model sizes 100x larger than the GNN. 
On the other hand, directly adopting GPUs on large graphs remains challenging because GPU memory capacity is limited and can be insufficient. As an example, modern graph benchmark datasets, e.g., OBGN-protein, can take up to 350 gigabytes (GBs) of memory, which requires multiple GPUs at an estimated cost of $400K.  </p>
 <p><center> <img src="research/GNN2.PNG" width="750" height=auto></center></p>
 
 <p><li> <b>First, my research focuses on the generalizability and convergence analysis of implementing graph neural networks in graph structured data learning</b>. 
</li></p>

 <p><li> <b>Second, my research focuses on developing graph sparsification methods to reduce the computational cost and sample complexity in training graph neural networks with theoretical guarantees</b>. For example, our proposed joint edge-model sparsification algorithm achieves a similar performance as training on the original data and model with a significant reducation at the computation cost (number near the data point denotes the required MACs).
</li></p>
 <p><center> <img src="research/GNN3.PNG" width="600" height=auto></center></p>
  <p><li><b>Selected Publications</b>:</p>
</li>
</ul>
<ol>
 <li><p><b>Shuai Zhang</b>, Meng Wang, Pin-Yu Chen, Sijia Liu, Songtao Lu, Miao Liu. “<em>Joint Edge-Model Sparse Learning is Provably Efficient for Graph Neural Networks.</em>” In International Conference on Learning Representations (<b>ICLR</b>), 2023. [<a href="Pub/ICLR23.pdf">pdf</a>]</p>
</li>
  <li><p><b>Shuai Zhang</b>, Meng Wang, Sijia Liu, Pin-Yu Chen, and Jinjun Xiong. “<em>Fast Learning of Graph Neural Networks with Guaranteed Generalizability: One hidden-layer Case.</em>” In Proc. of 2020 International Conference on Machine Learning (<b>ICML</b>), pp. 11268-11277. PMLR, 2020. [<a href="Pub/ICML20.pdf">pdf</a>]</p>
</li>
</ol>

<h2>Low-rank Hankel Matrix Completion <a href="research/MC.pdf">[slides]</a> </h2>
<p><b>Discription</b>: Given given partially observed data, we need to recover original data by filling in missing entries and removing outliers. This problem is common in various fields such as recommendation systems, computer vision, and signal processing. To illustrate, imagine a data matrix representing the renewable energy output of multiple solar arrays over time. The time-series data for each array may be affected by a few shared factors, like temperature, wind speed, and UV index. As there are more data points than factors, it suggests that the data matrix is low-rank. Being able to fill in missing data or predict future outputs is crucial for energy systems planning and control. However, existing algorithms require at least one observation in each column, making it unfeasible to apply them in practical scenarios where all data is lost or inaccessible, such as prediction tasks. To solve this issue, we utilize the Hankel matrix to capture the temporal correlation across the data. We propose non-convex algorithms by exploring the structured Hankel matrix, and the algorithms achieve <b> reduced sample complexity </b> and <b> less computational time </b> with <b> theoretical guarantees</b>. Our specific contributions include </p>
 <p><center> <img src="research/MC1.PNG" width="600" height=auto></center></p>
  

  
<p><li> <b>First, we propose a non-convex approach with convergence analysis for data satisfying low-rank Hankel property</b>, e.g., video processing, image super-resolution, medical image reconstruction, direction-of-arrival estimation, and linear dynamical systems.  For a data matrix satisfying low-rank Hankel property with rank r, our algorithm converges to the ground truth with exponential decay, while existing convex approximation approaches only enjoy a sub-linear converge rate.
</li></p>

<center> <img src="research/MC2.PNG" width="700" height=auto> </center>
  
<p><li><b>Second, Our algorithm is capable of withstanding the loss of a constant fraction of columns, whereas traditional methods are unable to cope with even a single lost column. </b>  For a data matrix satisfying low-rank Hankel property with rank  r, our algorithm can tolerate up to 1/r fraction of column-wise lost or corruptions. 
</li> </p> 
  
  <p><center> <img src="research/MC4.PNG" width="600" height=auto> </center></p>

<p><li><b>Third, Our algorithm requires less number of samples and less computational time to recover the ground truth. </b>  For a time-series matrix with dimension of n times n satisfying low-rank Hankel property,  we can save the sample complexity by a fraction of 1/n and the computational complexity by a fraction of  1/n per iteration compared with traditional appraoches.
</li></p>  
 

<p><li><b>Selected Publications</b>:</p>
</li>
</ul>
<ol>
<li><p><b>Shuai Zhang</b>, Meng Wang, Sijia Liu, Pin-Yu Chen, and Jinjun Xiong. Shuai Zhang, and Meng Wang. “<em>Correction of corrupted columns through fast robust Hankel matrix completion.</em>” IEEE Transactions on Signal Processing (<b>TSP</b>), no. 10: 2580-2594. IEEE, 2019. [<a href="Pub/TSP2.pdf">pdf</a>]</p>
</li>
  
<li><p><b>Shuai Zhang</b>, Yingshuai Hao, Meng Wang, and Joe H. Chow. “<em>Multichannel Hankel matrix completion through nonconvex optimization.</em>” IEEE Journal of Selected Topics in Signal Processing (<b>JSTSP</b>), no. 4: 617-632. IEEE, 2018. [<a href="Pub/TSP1.pdf">pdf</a>]</p>  
</li>  
</ol>

</tr>
</table>
</body>
</html>
